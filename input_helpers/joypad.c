// Author: oscar (https://github.com/oscarkcau)
//
// CLI tool for Miyoo A30 handheld,
// it reads keyboard input events (generated by button tappings) 
// and send events to new virtual joypad device.
//
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/uinput.h>
#include <poll.h>

void print_usage();

void print_usage() {
    fprintf(stdout, "usage: joypad input_device\n");
    fprintf(stdout, "Read input from input_device and send events to new virtual joypad device.\n\n");
}

int main(int argc, char *argv[])
{
    // open /dev/uinput
    int fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);
    if (fd < 0)
    {
        fprintf(stderr, "could not open /dev/uinput\n");
        print_usage();
        return 1;
    }

    // declare keyboards and buttons events will be generated
    ioctl(fd, UI_SET_EVBIT, EV_KEY);
    // declare stateful binary switch events will be generated
    ioctl(fd, UI_SET_EVBIT, EV_SW);

    // declare buttons for new virtual joypad
    ioctl(fd, UI_SET_KEYBIT, BTN_A);
    ioctl(fd, UI_SET_KEYBIT, BTN_B);
    ioctl(fd, UI_SET_KEYBIT, BTN_X);
    ioctl(fd, UI_SET_KEYBIT, BTN_Y);
    ioctl(fd, UI_SET_KEYBIT, BTN_TL);
    ioctl(fd, UI_SET_KEYBIT, BTN_TR);
    ioctl(fd, UI_SET_KEYBIT, BTN_START);
    ioctl(fd, UI_SET_KEYBIT, BTN_SELECT);
    ioctl(fd, UI_SET_KEYBIT, BTN_MODE);
    ioctl(fd, UI_SET_KEYBIT, BTN_THUMBL);
    ioctl(fd, UI_SET_KEYBIT, BTN_THUMBR);

    // declare analog absolute axis events will be generated
    ioctl(fd, UI_SET_EVBIT, EV_ABS); 

    // declare axis input for new virtual joypad 
    ioctl(fd, UI_SET_ABSBIT, 0);
    ioctl(fd, UI_SET_ABSBIT, 1);
    ioctl(fd, UI_SET_ABSBIT, 2);
    ioctl(fd, UI_SET_ABSBIT, 3);
    ioctl(fd, UI_SET_ABSBIT, 4);
    ioctl(fd, UI_SET_ABSBIT, 5);
    ioctl(fd, UI_SET_ABSBIT, 16);
    ioctl(fd, UI_SET_ABSBIT, 17);

    // describe joypad information
    struct uinput_user_dev dev;
    memset(&dev, 0, sizeof(dev));
    snprintf(dev.name, UINPUT_MAX_NAME_SIZE, "MIYOO Pad1");
    dev.id.bustype = BUS_USB;
    dev.id.vendor = 0x045e;
    dev.id.product = 0x028e;
    dev.id.version = 0x045e;

    // describe minimum and maximum values of axis input
    for (int i=0; i<64; i++)
    {
        dev.absmin[i] = -256;
        dev.absmax[i] = 256;
    }
    dev.absmin[0] = -128;
    dev.absmax[0] = 128;
    dev.absmin[1] = -128;
    dev.absmax[1] = 128;
    dev.absmin[16] = -1;
    dev.absmax[16] = 1;
    dev.absmin[17] = -1;
    dev.absmax[17] = 1;

    // write joypad information to create new input device
    write(fd, &dev, sizeof(dev));
    if (ioctl(fd, UI_DEV_CREATE))
    {
        perror("UI_DEV_CREATE");
        print_usage();
        return 1;
    }

    int fd_in;
    int ret;
    struct pollfd pfd;
    struct input_event event;

    // check number of arguments
    if (argc != 2)
    {
        fprintf(stderr, "wrong number of arguments\n");
        print_usage();
        return -1;
    }

    // open keyboard input device
    fd_in = open(argv[1], O_RDONLY);
    if (fd_in <= 0)
    {
        fprintf(stderr, "could not open %s\n", argv[1]);
        print_usage();
        return -1;
    }

    pfd.fd = fd_in;
    pfd.events = POLLIN;

    while (1)
    {
        unsigned short type = 0;
        unsigned short code = 0;
        int value = 0;

        // poll one event at a time
        poll(&pfd, 1, -1);
        if (!(pfd.revents & POLLIN))
            continue;

        // read the event
        ret = read(pfd.fd, &event, sizeof(event));
        
        // ignore on reading error
        if (ret < (int)sizeof(event))
        {
            fprintf(stderr, "could not get event\n");
            continue;
        }

        // skip event separator
        if (event.type == 0)
            continue;

        // map keyboard events to joypad events
        switch (event.code)
        {
        case KEY_ESC:
            type = EV_KEY;
            code = BTN_MODE;
            value = event.value;
            break;
        case KEY_UP:
            type = EV_ABS;
            code = 17;
            value = (event.value == 1) ? -1 : 0;
            break;
        case KEY_DOWN:
            type = EV_ABS;
            code = 17;
            value = (event.value == 1) ? 1 : 0;
            break;
        case KEY_LEFT:
            type = EV_ABS;
            code = 16;
            value = (event.value == 1) ? -1 : 0;
            break;
        case KEY_RIGHT:
            type = EV_ABS;
            code = 16;
            value = (event.value == 1) ? 1 : 0;
            break;
        case KEY_SPACE:
            type = EV_KEY;
            code = BTN_B;
            value = event.value;
            break;
        case KEY_LEFTCTRL:
            type = EV_KEY;
            code = BTN_A;
            value = event.value;
            break;
        case KEY_LEFTSHIFT:
            type = EV_KEY;
            code = BTN_Y;
            value = event.value;
            break;
        case KEY_LEFTALT:
            type = EV_KEY;
            code = BTN_X;
            value = event.value;
            break;
        case KEY_TAB:
            type = EV_KEY;
            code = BTN_TL;
            value = event.value;
            break;
        case KEY_BACKSPACE:
            type = EV_KEY;
            code = BTN_TR;
            value = event.value;
            break;
        case KEY_E:
            type = EV_ABS;
            code = 2;
            value = (event.value == 1) ? 255 : 0;
            break;
        case KEY_T:
            type = EV_ABS;
            code = 5;
            value = (event.value == 1) ? 255 : 0;
            break;
        case KEY_ENTER:
            type = EV_KEY;
            code = BTN_START;
            value = event.value;
            break;
        case KEY_RIGHTCTRL:
            type = EV_KEY;
            code = BTN_SELECT;
            value = event.value;
            break;
        }

        // send event to joypad
        event.type = type;
        event.code = code;
        event.value = value;
        ret = write(fd, &event, sizeof(struct input_event));

        // send event separator to joypad
        event.type = EV_SYN;
        event.code = SYN_REPORT;
        event.value = 0;
        ret = write(fd, &event, sizeof(struct input_event));
    }

    // unreachable code below, for completeness only
    if (ioctl(fd, UI_DEV_DESTROY))
    {
        printf("UI_DEV_DESTROY");
        return 1;
    }

    close(fd);
    return 0;
}
